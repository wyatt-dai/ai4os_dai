[TOC]

## 引言
本学习笔记以rcore“裸机实现hello world运行的最小系统”为参照，去对比成熟os的各个模块，我的思路是大部分人其实更了解的还是成熟操作系统的知识，而这种简化性质的逻辑程序理应可以对应到一些成熟os的功能，从成熟os的功能现阶段是否有必要的角度去思考，为os开发一个思路
👉 重点解释：
它对应什么？为什么是这样？为什么现在可以不需要其他更复杂的机制？

我将ch1中与os能对应的模块分为
- 程序入口点
- rustsbi
- 异常处理
还有为实现hello world必要的模块
- 初始化栈
- 链接脚本
会按几个核心维度逐一比较。

一、程序入口点
在我们学习的操作系统知识中，一个os的接电开始运行是通过**开机后启动bios** -> **bios去磁盘的特定分区，也就是MBR找到bootloader进行执行**，其中MBR的位置通常是整个磁盘的最开始，也就是零号扇区
ch1中的start函数与链接脚本的配合就是对上述流程的最简化，主要在于因为本章目标仅仅是完成hello world的执行，并不需要操作系统载入和初始化等复杂的启动流程，所以可以直接通过链接脚本将其放在sbi启动完毕后的固定跳转地址0x8020_0000
即sbi启动 → 固定的地址（入口函数） → 直接进入主逻辑
成熟操作系统中的对应启动路径是：
固件 → 引导程序 → 内核入口 → 子系统初始化
本质上只是把“固定跳转”拆分成了多个阶段，用来支持：
- 不同磁盘布局
- 不同硬件平台
- 可替换内核
裸机启动不是“不同机制”，而是把多级引导压缩为单级跳转。

二、特权级与 SBI：从“直接依赖”到成熟系统的“分层抽象”
ch1中的做法：
rustsbi相当于上面所属的bios的作用，作为一个初始启动的固件，并为程序运行提供一些基础库，程序运行在 S-mode，相当于实模式的运行，可以直接执行特权指令，所有“硬件相关能力”通过 SBI 转交给 M-mode，形成了
内核 → 固件 → 硬件
即现阶段证明“内核可以运行”，后续补充中进行更复杂的特权级切换实现，产生内核态和用户态的区分

三、异常与 panic
裸机中：
panic 直接触发关机
有点强行比较，但可以视作中断中异常处理的功能，只不过因为只有一种措施，并且处于s-mode,所以相比成熟系统中：有异常向量、有错误分类、有各类策略的情况，并不需要进行到内核态的转移，也不需要查向量表。

四、函数正常执行：栈初始化和链接
为了函数正常使用，进行必要的栈初始化，这一点很明显
定制链接脚本的原因会更复杂一些
- 入口函数放置，上面已经解释
- 定制段：回顾一下编译原理的内容，编译器/链接器生成的是：ELF 文件，里面有：.text .rodata .data .bss等各个段，但ELF 里描述的是：“我有这些段”而不是：“它们一定在内存的哪个地址”，os会进行指定，裸机没有os,所以需要直接固定位置，该脚本就是直接放在了0x8020_0000后连续存储。


八、学习意义上的结论

从裸机实现出发学习操作系统的意义在于：
- 可以观察到：
控制权如何从硬件交给软件
软件如何自举自身运行环境
- 可以明确：
所有高级机制（进程、内存、文件系统）都建立在这个最小执行模型之上
- 可以理解：
成熟操作系统不是凭空出现的，而是在这一最小模型上逐层叠加出来的

一句话总结：
裸机最小程序展示的是：“如果世界上只有一个程序，操作系统需要长成什么样子”
成熟操作系统展示的是：“当世界上有很多程序时，如何管理它们”。