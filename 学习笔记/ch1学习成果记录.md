[TOC]

## 引言
本学习笔记以rcore“裸机实现hello world运行的最小系统”为参照，去对比成熟os的各个模块，我的思路是大部分人其实更了解的还是成熟操作系统的知识，而这种简化性质的逻辑程序理应可以对应到一些成熟os的功能，从成熟os的功能现阶段是否有必要的角度去思考，为os开发一个思路
👉 重点解释：
它对应什么？为什么是这样？为什么现在可以不需要其他更复杂的机制？

我将ch1中与os能对应的模块分为
- 程序入口点
- rustsbi
- 异常处理
还有为实现hello world必要的模块
- 初始化栈
- 链接脚本
会按几个核心维度逐一比较。

一、程序入口点
在我们学习的操作系统知识中，一个os的接电开始运行是通过**开机后启动bios** -> **bios去磁盘的特定分区，也就是MBR找到bootloader进行执行**，其中MBR的位置通常是整个磁盘的最开始，也就是零号扇区
ch1中的start函数与链接脚本的配合就是对上述流程的最简化，主要在于因为本章目标仅仅是完成hello world的执行，并不需要操作系统载入和初始化等复杂的启动流程，所以可以直接通过链接脚本将其放在sbi启动完毕后的固定跳转地址0x8020_0000
即sbi启动 → 固定的地址（入口函数） → 直接进入主逻辑
成熟操作系统中的对应启动路径是：
固件 → 引导程序 → 内核入口 → 子系统初始化
本质上只是把“固定跳转”拆分成了多个阶段，用来支持：
- 不同磁盘布局
- 不同硬件平台
- 可替换内核
裸机启动不是“不同机制”，而是把多级引导压缩为单级跳转。

二、特权级与 SBI：从“直接依赖”到成熟系统的“分层抽象”
ch1中的做法：
这里的理解引用我在rcore-tutorial看到的一段话，我本来理解把sbi比作bios,是错误的，其在bios后，在bootloader前：
```
SBI 是 RISC-V Supervisor Binary Interface 规范的缩写，OpenSBI 是RISC-V官方用C语言开发的SBI参考实现；RustSBI 是用Rust语言实现的SBI。

BIOS 是 Basic Input/Output System，作用是引导计算机系统的启动以及硬件测试，并向OS提供硬件抽象层。

机器上电之后，会从ROM中读取引导代码，引导整个计算机软硬件系统的启动。而整个启动过程是分为多个阶段的，现行通用的多阶段引导模型为：

ROM -> LOADER -> RUNTIME -> BOOTLOADER -> OS

Loader 要干的事情，就是内存初始化，以及加载 Runtime 和 BootLoader 程序。而Loader自己也是一段程序，常见的Loader就包括 BIOS 和 UEFI，后者是前者的继任者。

Runtime 固件程序是为了提供运行时服务（runtime services），它是对硬件最基础的抽象，对OS提供服务，当我们要在同一套硬件系统中运行不同的操作系统，或者做硬件级别的虚拟化时，就离不开Runtime服务的支持。SBI就是RISC-V架构的Runtime规范。

BootLoader 要干的事情包括文件系统引导、网卡引导、操作系统启动配置项设置、操作系统加载等等。常见的 BootLoader 包括GRUB，U-Boot，LinuxBoot等。
```
内核 → 固件 → 硬件
即现阶段证明“内核可以运行”，后续补充中进行更复杂的特权级切换实现，产生内核态和用户态的区分

三、异常与 panic
裸机中：
panic 直接触发关机
有点强行比较，但可以视作中断中异常处理的功能，只不过因为只有一种措施，并且处于s-mode,所以相比成熟系统中：有异常向量、有错误分类、有各类策略的情况，并不需要进行到内核态的转移，也不需要查向量表。

四、函数正常执行：栈初始化和链接
为了函数正常使用，进行必要的栈初始化，这一点很明显
定制链接脚本的原因会更复杂一些
- 入口函数放置，上面已经解释
- 定制段：回顾一下编译原理的内容，编译器/链接器生成的是：ELF 文件，里面有：.text .rodata .data .bss等各个段，但ELF 里描述的是：“我有这些段”而不是：“它们一定在内存的哪个地址”，os会进行指定，裸机没有os,所以需要直接固定位置，该脚本就是直接放在了0x8020_0000后连续存储。


五、学习意义上的结论

从裸机实现出发学习操作系统的意义在于：
- 可以观察到：
控制权如何从硬件交给软件
软件如何自举自身运行环境
- 可以明确：
所有高级机制（进程、内存、文件系统）都建立在这个最小执行模型之上
- 可以理解：
成熟操作系统不是凭空出现的，而是在这一最小模型上逐层叠加出来的

一句话总结：
裸机最小程序展示的是：“如果世界上只有一个程序，操作系统需要长成什么样子”
成熟操作系统展示的是：“当世界上有很多程序时，如何管理它们”。
